---
title: "Leaf Phenology"
author: 'FREC 3004: Environmental Informatics'
output:
  github_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```
## Science question

How is the timing of spring-leaf out changing over time?

## Learning objectives
* Practice working with vectors, matices, and arrays.
* Extract relevant information from a 3 dimensional data-set
* Understand the importance of leaf phenology as a measure of climate change
* Analyze a phenology time-series and assess if leaf-on, leaf-off, and growing 
  season length are changing.

## Why this matters:  

Forests absorb ~25% of annual fossil fuel emmisions. If the length of the 
growing season changes, then this climate regulation service may be altered. 
This has important implications for establishing a sustainable level of future 
emmisions.

## Initate project

First, create a directory structure for this module (i.e., project). 

* Create a folder called `FREC3004_Module_LeafPhenology`

Within that folder, create folders for the following

* `doc`: where you will put text documents associated with the project
* `data_raw`: where you will put raw data and metadata
* `results`: where you will save files generated by analysis
* `src`: where you will save your scripts (i.e., .R files), if any, other than 
   your .Rmd file.  The .Rmd file must be in the main directory
  
Save this file in the `FREC3004_Module_LeafPhenology` directory

Load the `tidyverse`. Install and load the `jpeg` and `raster` packages.

```{r, message = FALSE}
library(jpeg)
library(raster)
```

**Important note:** Some packages have functions with the same name so loading 
both packages causes issues.  This is the case with the select() function that 
exists in both `dplyr` and `raster` packages.  To address this issue you can 
reference, using ::, the specific package you want to use.  For example 
`dplyr::select()` uses the select() from dplyr (in tidyverse) while 
`raster::select()` uses select from the raster package.

## Vectors, Matrix, and Arrays

So far you have been working with data frames/tibbles and had some introduction 
to vectors in Module 4 (https://datacarpentry.org/R-ecology-lesson/01-intro-to-r.html).
Here we will explore some more general data classes you will need to be familiar
with to complete this module.

Start by making 10 random numbers between 0 and 100 using the `runif` function.
Then use the `c` function to convert to a vector.

```{r}
#INSERT CODE HERE
rando <- runif(n = 5, min = 0, max = 100)
```

Select the first cell in this vector using `[]` indexing. Follow by selecting 
the second through fourth cells simultaneously.

```{r}
#INSERT CODE HERE
```

Make a 5 x 5 matrix filled with NAs using the `matrix` function.

```{r}
my_matrix <- matrix(data = NA, nrow = 5, ncol = 5)
my_matrix
```

Fill the matrix with random numbers, you will need more than 5 random numbers to
fill the matrix. You can ask for 25 values explicitly or you can automatically 
determine the amount of values you require using the `length` function. To 
select all values we will need to qualify the matrix using `[, ]`. 

In R the first posistion is row, and the second posistion is the column. When 
the posistion is empty, it implies all avaible rows and/or columns are selected. 

```{r}
my_matrix[, ] <- 
my_matrix
```

This matrix should begin to look like the data frames you are accustomed to. 

**Question 1:** How is a matrix different from a data frame (tibble)?

**Answer 1:**


To select a single value from a matrix, use the `[]` indexing again, but this 
time we need to specify the two dimensions. In R, do this by separting the row 
and column dimensions with a comma. For example, `mymatrix[1, 2]` is the 1st row
and the 2nd column of `mymatrix`. If the posistion is left empty it implies that
you are requesting all the columns/rows. For example,`mymatrix[2, ]` will select
the second row, and all columns.

Select the second row, and the third column.

```{r}
#INSERT CODE HERE
```

Select the second through fourth rows, and the fourth and fifth columns. Display
this as a matrix.

```{r}
#INSERT CODE HERE
```

Now select the second, fourth, and first, column, but all rows.

```{r}
#INSERT CODE HERE
```

Vectorize the output from the previous step using the `c()` function.

```{r}
#INSERT CODE HERE
```

**Question 2:**
What did vectorizing do to the matrix? What informaton did we lose?

**Answer 2:**

Finally, create an array. This array will have 3 dimensions, rows, columns, and 
layers. In R, array indexing is an expansion of matrix indexing such that 
`MYARRAY[1, 2, 3]` is the first row, second columns, third layer of the array.
Use the `array` function to create a 5x5x3 array of NAs. Display the array.

```{r}
my_array <- array(NA, dim = c(ROWS, COLUMNS, LAYERS))
my_array
```

Now fill the array with the required amount of random numbers. Try to determine 
the amount of numbers required using a functions (don't hard code it). Display 
your array when done.

```{r}
#INSERT CODE HERE
```
 
Select the second row, third column, and second layer of this array

```{r}
#INSERT CODE HERE
```

Select all elements in the first layer

```{r}
#INSERT CODE HERE
```

**Question 3:**
What kind of object is this?

**Answer 3:**

Select the second row, third column, but all layers

```{r}
#INSERT CODE HERE
```
 
**Question 4:**
What kind of object is this?

**Answer 4:**

**Question 5:**
Based on your answer to above two questions, what are the components of an 
array? 

**Answer 5:**
Arrays are a set of __________
Matrices are a set of __________
Vectors are a set of __________

## Working with images

Go to the phenocam network website 'https://phenocam.sr.unh.edu/webcam/'. 
Explore the website and find the 'sweetbriar' site page. Look at the EN_1000 
ROI page, and then the DB_1000 ROI page. Download the provisonal data from the 
`DB_1000` ROI page into the appropriate data directory.

**Question 6:**
Explain why we are or are not in compliance with the data policy.  The policy 
can be found here: https://phenocam.sr.unh.edu/webcam/fairuse_statement/

**Answer 6:**

Unzip the folder you just downloaded and explore using the file explorer on your
computer. Find and import the JPEG for the most recent day into R using 
`readJPEG` from the `jpeg` package. We will need this data layer so be sure to 
save this to a new object.

```{r}
img <- readJPEG(source = "/Users/quinn/Downloads/provisional_data/data_record_2/sweetbriar_2018_06_13_120007.jpg")
```


**Question 7:**
* What class is this object? 
* What are it's dimensions? 
* Look inside the array at the row and column that correspond to the month and 
  day of your birthday (just as a set of example numbers), leave the layer empty. 
  What data do these three numbers represent? 

**Answer 7:**
```{r}
#INSERT CODE HERE
```

Since the data in each layer is unique to that layer, we can think of this file 
as a 3 dimensional data frame. This type of data can be called a `raster`. A 
raster is one layer with two dimensions, while a brick/stack are multiple 
layers. Each layer of brick/stack myst share the same two x and y (row and 
column) dimensions.

Now load the same JPEG into R using the `brick` function from the raster 
package. Look at the header of the brick object by typing the name of this new 
brick object.

```{r}
img2 <- brick("/Users/quinn/Downloads/provisional_data/data_record_2/sweetbriar_2018_06_13_120007.jpg")
img2 #this will print the header of the brick
```

**Question 8:**
What is the difference is between how the `brick` and  `readJPEG` functions 
interpreted the same input file?

**Answer 8:**


Plot the brick using the `plot` function. 

```{r}
#INSERT CODE HERE
```

**Question 9:**
Describe what you see. Be detailed about what data you think are represented in 
the different plots.

**Answer 9:**


Now use the `plotRGB` function. 

```{r}
plotRGB(img2)
```

**Question 10:**
How does the `plotRGB` interpret and display the same data differently than the 
`plot` function.

**Answer 10:**

## GCC Calculation, One Pixel

There are a variety of indices for vegetation. You have probably heard of the 
Normalized Difference Vegetation Index (NDVI). NDVI is calculated from red and 
near-infrared light. 

Here we will use Green Chromatic Coordinate (GCC). 

GCC = Green/(Red + Green + Blue). 

Plants use chlorophyll to synthesize sugar from light. Chlorophyll is green in 
color, therefore, how green a plant is can be an indicator of its photosynthetic
activity, especially with deciduous species. Furthermore infrared cameras are 
expensive, but normal  visibile light cameras are not.  We need to use a 
relative greeness index because some days have more green just because the sun 
is brighter, not because there is more chlorophyll. By dividing by the sum of 
red, green, and blue, the GCC normalizes for the brightness of the day.

Select a pixel (i.e., pick a set of X and Y coordinates) but all layers from the
array version of this jpeg. Calculate the GCC of this pixel.

Remember in JPEGs, Layer 1 = Red, Layer 2 = Green, and Layer 3 = Blue. 

**Question 11:**  What is the GCC of your pixel?

**Answer 11:**
```{r}
#INSERT CODE HERE
```

## Multi Pixel Calculations

Repeat this calculation of GCC for 25 pixels. For now the group is arbitrary and
select them however you wish. Calculate the GCC of each individual pixel using 
the array form of your jpeg.  

NOTE: be sure you have selected only 25 pixels.  If your array is really big 
then you have likely selected 25x25 pixels, which is too many.

```{r}
#INSERT CODE HERE
```

Make a histogram of the GCC from your multiple pixels. You may need to vectorize
GCC before making the histogram and convert to a tibble for ggplot to understand.

```{r}
#INSERT CODE HERE
```

We will need to summarize this group of numbers.  The Phenocam researchers 
recommend using the 90th Percentile of GCC, rather than other metrics like the 
mean. Use the `quantile` function to attain the 90th percentile of GCC.

```{r}
quantile(GCC OBJECT, probs = c(0.9))
```

## Working with rasters

Now we will calculate the GCC of the entire image. We can perform pixel by pixel
arithmetic using the raster package or we can vectorize the data. Here we will 
try both. Using the `subset` function perform the GCC calculation on the entire 
image. When you use the `sum` function on a raster brick, it assumes you want to
perform the operaton across layers, and not across rows and columns.

```{r}
#GCC <- raster::subset(BRICK IMAGE, subset = GREEN LAYER) / sum(BRICK IMAGE)
GCC <- raster::subset(img2, subset = 2) / sum(img2)
```

Plot the GCC for the entire image output using the `plot` function.

```{r}
#INSERT CODE HERE
plot(GCC)
```

To compare to the GCC plot, redo the plot of the orginal image using `plotRGB`. 

```{r}
#INSERT CODE HERE
```

**Question 12:**
What region of the GCC plot has the higheset GCC values?  What region of the RGB
image is the most green?  Do the GCC data and RGB images agree?  

**Answer 12:**


Now vectorize the GCC raster you just created using the `as.vector` function, 
and summarize the results by taking the 90th percentile again.

```{r}
gcc <- as.vector(GCC RASTER)
#INSERT CODE HERE
```

**Question 13:**
Describe how many different types of regions (i.e., different plant types, sky, 
roads, etc.) that you can break the image into.  All of these regions are 
blended in the summarized value for GCC.

**Answer 13:**

## Cropping

The group of pixels you selected before was arbitrary, now we want to select a 
non-arbitrary group of pixels that define focal regions within the image. For 
this portion we will use the brick form of the JPEG.

Replot, the jpeg using plotRGB. What would be a non-arbitrary group of pixels? 
How would you select for them? 

You wll to copy this next code chunk into a new window .R document for it to run
properly.  After you have a set of values for extent, be sure to comment out 
this chunk of code so that your Rmarkdown will knit.  

```{r}
plotRGB(img2)
yourbox <- drawExtent() 
yourbox
```

Hard code this extent using the `extent` function into this Rmarkdown document 
so that it knits correctly

```{r}
yourbox <- extent(c(xmin , xmax , ymin, ymax))
```

Now we can crop the image by the extent you just created. Use the `crop` 
function from the raster package and `plotRGB` the new image.  EXTENT is the 
variable with the values for your extent.

```{r}
___ <- crop(x=BRICK IMAGE, y = EXTENT)
```

Now repeat the GCC calculation for this non-arbitraty subset of pixels. It will 
be most efficient to vectorize each layer and then perform the calculation. 
Do this using the `subset` function and the `as.vector` function. Use the code 
for the first layer as a guide. Remember that the GCC caclulation must be done 
on each individual pixel independently before summarizing. Diplay the first 10 
values. 

```{r}
r <- as.vector(subset(CROPPED IMAGE, subset = 1))
#INSERT CODE HERE
```

Now summarize with the 90th percentile using the `quantile` function.

```{r}
#INSERT CODE HERE
```

## Masking

In the previous step we used a rectangle to subset the pixels. This leaves out a
large number of usable information that could be included by having an 
irregularly shaped filter. We won't be making one here but we will what has been
previously created by the site managers.

Using the region of interest (ROI) that was assigned to this data by the site 
managers, we will filter out all pixels not in the ROI . Start by loading the 
mask into R using the `raster` function. You will find it in the data_record_2 
folder as a `.tif` file. Plot it.

```{r}
my_mask <- raster('TIF PATH')
#INSERT CODE HERE
```


The image should have two values (0 and 255). You can use either of these values
to mask, depending on what region you want to focus on.  We are interested in 
the smaller region because the ROI consists of one type of forest (it is the 
decidious forest on the hillside).  You will provide the mask function the value
(maskvalue) of the region that want to exclude from further analysis.

```{r}
MASKED <- mask(x = BRICK IMAGE, mask = MASK, maskvalue = APPROPRIATE MASK VALUE)
#INSERT CODE HERE
```

Plot the masked image that you just created using `plotRGB`.

```{r}
#INSERT CODE HERE
```

Calculate the GCC of this new object using `as.vector` and `subset`. Calculate 
90th percentile GCC as before. 

```{r}
#INSERT CODE HERE
```

**Question 14:**
How does summary number differ from the entire image number? Why is there a 
difference in GCC between the ROI and the entire image?

**Answer 14:**


## Time Series

Now that we understand how the GCC calculation is done on a single image from a 
single date we will repeat this procedure for multiple images, utlimately 
resulting in a time series. 

Manually download (by clicking on and saving) the noon image from each Sunday in
April of 2018 into your data folder. It is helpful to use the same time from 
each day so that approximately the same amount and angle of light is present. 
Here is the link to the April, 2018 page: `https://phenocam.sr.unh.edu/webcam/browse/sweetbriar/2018/04/`. You should end 
up with 5 images in your data directory.

Build a tibble with column for date and a column for the GCC (90th percentile 
from an ROI).  To build this you will use a `for` loop to 1) read in these 
images using the brick function (use the brick() because it plays well with the 
mask function), 2) mask them using the provided TIF MASK, 3) calculate the GCC 
for each relevant pixel, 4) summarize the GCC in the ROI by calculating and 
saving the 90th percentile, and 5) extract the date information from the file 
name to create a date-time variable.  I recommend creating a percentile vector 
and an image_day vector before the for-loop that you fill in within the 
for-loop. Then combine these variables into a tibble after the for-loop.


```{r}
percentile90 <- rep(NA, length(HOW MANY FILES DO YOU HAVE?))
image_date <- rep(NA, length(HOW MANY FILES DO YOU HAVE?))

#Insert for loop that loops over the images

gcc_data <- tibble(date = image_date,
                   percentile90 = percentile90)
```

Plot your results

```{r}
#INSERT CODE HERE
```

**Question 15**
Describe the pattern of GCC over this time period.

**Answer 15**

Now that we know how to calculate GCC from multiple images, I know that you are 
capable of repeatig this calculation for a every day of the year for multiple 
years. To save time we will use previously calculated GCC from this ROI to 
complete this analysis.

From the provisional data, load the 3 day GCC data file (a csv file) into R and 
plot the 90th percentile of greenness for the whole record. You will find this 
in data record folder 4.

```{r}
#INSERT CODE HERE
```

Now subset your data by calendar year and plot each year in its own window using
the `facet_wrap` function.

```{r}
#Here is starting code with the facet_wrap included
ggplot() + 
  geom_point() +
  facet_wrap(~ year)
```

**Question 15**
Describe the pattern that each year follows. Visually estimate the day of year 
for the start and end of the growing season for each year. 

**Answer 15 **


## Curve Fitting

We have a data set of GCC over time. In order to extract ecologically relevant 
data such as start of growing season, we need to fit a curve to the data to more
quantiatively determined when the growing season starts. Here will start by 
using the `smooth.spline` function. Subset the data to 2016, plot the GCC and 
the smoothed curve. Experiment with the "spar" argument until you are satisfied 
that you are representing the broad signal without overfitting.

[ISSUES SPAR!]

```{r}
three_day <- read_csv("data/provisional_data/data_record_4/sweetbriar_DB_1000_3day.csv", skip = 22)
gcc_spline <- smooth.spline(y = GCC, x = DAY OF YEAR,spar = VALUE BETWEEN 0 and 1)
#INSERT CODE HERE
```

In order to determine the start and end of the growing season automatically. We 
will need to use the `predict` function to take the derivative of your smoothed 
curve. Plot the derivative. 


```{r}
gcc_spline_deriv <- predict(gcc_spline, x = seq(1,365,0.25), deriv = 1)
ggplot(gcc_spline_deriv)
```

```{r}
#INSERT CODE HERE
```


Use the results from the spline deriviving to determine the start of the growing
season, end of growing season and it's length? There is no right answer but your
solution must be defensible, and repeatable.

```{r}
#INSERT CODE HERE
```

Replot the GCC time-series from this year with vertical lines representing the 
start and end that you have determined from the analysis of the spline 
derivative.

```{r}
#INSERT CODE HERE
```

Repeat this process for all complete years, make a data frame of the start, end 
and length of the growing season for each year. Plot your results

```{r}
#INSERT CODE HERE
```

## Next Steps

Find a new and unique site on the phenocam website with a Deciduos broadleaf 
tree ROI with at least 3 complete years of data (if you site only has 3 year be 
careful and double check that they are all complete), download its provisional 
data. Process the 3 day GCC product as we have done here.

**Question 12** Plot the camera image

**Answer 12**

```{r}


```

**Question 13:** Plot the GCC curves with your fitted model and start, and end 
dates displayed as vertical lines.

**Answer 13:**
```{r}


```

**Question 14:** Create a plot showing how the start, end, and length of growing
season is changing over time for your site.

**Question 14:**

```{r}


```

## References

This module was originally developed by Ben Ahlswede.
